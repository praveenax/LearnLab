"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var axis_util = require("../axis_util");
var math_1 = require("../math");
var ndarray = require("../ndarray");
var ndarray_1 = require("../ndarray");
var reduce_util = require("../reduce_util");
var types_1 = require("../types");
var addscaledmat_gpu_1 = require("./webgl/addscaledmat_gpu");
var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
var batchnorm_gpu_1 = require("./webgl/batchnorm_gpu");
var binaryop_gpu = require("./webgl/binaryop_gpu");
var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
var clip_gpu_1 = require("./webgl/clip_gpu");
var concat_gpu_1 = require("./webgl/concat_gpu");
var conv_backprop_gpu_1 = require("./webgl/conv_backprop_gpu");
var conv_gpu_1 = require("./webgl/conv_gpu");
var conv_gpu_depthwise_1 = require("./webgl/conv_gpu_depthwise");
var copy_gpu_1 = require("./webgl/copy_gpu");
var gpgpu_context_1 = require("./webgl/gpgpu_context");
var gpgpu_math = require("./webgl/gpgpu_math");
var gpgpu_util = require("./webgl/gpgpu_util");
var max_pool_backprop_gpu_1 = require("./webgl/max_pool_backprop_gpu");
var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
var multinomial_gpu_1 = require("./webgl/multinomial_gpu");
var onehot_gpu_1 = require("./webgl/onehot_gpu");
var pool_gpu_1 = require("./webgl/pool_gpu");
var reduce_gpu_1 = require("./webgl/reduce_gpu");
var resize_bilinear_gpu_1 = require("./webgl/resize_bilinear_gpu");
var slice_gpu_1 = require("./webgl/slice_gpu");
var texture_manager_1 = require("./webgl/texture_manager");
var tile_gpu_1 = require("./webgl/tile_gpu");
var transpose_gpu_1 = require("./webgl/transpose_gpu");
var unary_op = require("./webgl/unaryop_gpu");
var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
var webgl_util = require("./webgl/webgl_util");
var MathBackendWebGL = (function () {
    function MathBackendWebGL(gpgpu) {
        this.binaryCache = {};
        if (gpgpu == null) {
            var gl = gpgpu_util.createWebGLContext();
            this.gpgpu = new gpgpu_context_1.GPGPUContext(gl);
            this.gpgpuCreatedLocally = true;
        }
        else {
            this.gpgpu = gpgpu;
            this.gpgpuCreatedLocally = false;
        }
        this.textureManager = new texture_manager_1.TextureManager(this.gpgpu);
        ndarray.initializeGPU(this.gpgpu, this.textureManager);
    }
    MathBackendWebGL.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    MathBackendWebGL.prototype.clone = function (a) {
        var texShape = a.getTextureShapeRC();
        var source = a.as2D(texShape[0], texShape[1]);
        var output = this.makeOutputArray(texShape, a.dtype);
        this.copy2D(source, [0, 0], texShape, output, [0, 0], texShape);
        return output.reshape(a.shape);
    };
    MathBackendWebGL.prototype.slice1D = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram([size]);
        var customSetup = program.getCustomSetupFunc([begin]);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    MathBackendWebGL.prototype.slice2D = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    MathBackendWebGL.prototype.slice3D = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    MathBackendWebGL.prototype.slice4D = function (input, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [input], null, customSetup);
    };
    MathBackendWebGL.prototype.copy2D = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        var program = new copy_gpu_1.Copy2DProgram(sourceSizeRowCol[1], destSizeRowCol[1]);
        var customSetup = program.getCustomSetupFunc(sourceBeginRowCol, destBeginRowCol, destSizeRowCol);
        this.compileAndRun(program, [source], dest, customSetup);
    };
    MathBackendWebGL.prototype.concat1D = function (a, b) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, 0);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.concat2D = function (a, b, axis) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, axis);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.concat3D = function (x1, x2, axis) {
        var program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);
        return this.compileAndRun(program, [x1, x2]);
    };
    MathBackendWebGL.prototype.concat4D = function (x1, x2, axis) {
        var program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);
        return this.compileAndRun(program, [x1, x2]);
    };
    MathBackendWebGL.prototype.scaledArrayAdd = function (c1, a, c2, b) {
        var program = new addscaledmat_gpu_1.AddScaledMatProgram(a.shape, b.shape);
        return this.compileAndRun(program, [a, b, c1, c2]);
    };
    MathBackendWebGL.prototype.neg = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.NEG);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.makeOutputArray = function (shape, dtype) {
        var textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
        var texture = this.textureManager.acquireTexture(textureShapeRC);
        return ndarray_1.NDArray.make(shape, { texture: texture, textureShapeRC: textureShapeRC }, dtype);
    };
    MathBackendWebGL.prototype.compileAndRun = function (program, inputs, output, customSetup) {
        var _this = this;
        if (output == null) {
            output = this.makeOutputArray(program.outputShape, inputs[0].dtype);
        }
        var key = gpgpu_math.makeShaderKey(program, inputs, output);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputs, output);
        });
        gpgpu_math.runProgram(binary, inputs, output, customSetup);
        return output;
    };
    MathBackendWebGL.prototype.matMul = function (a, b, aOrientation, bOrientation) {
        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, aOrientation, bOrientation);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.multiply = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.tile = function (a, reps) {
        var program = new tile_gpu_1.TileProgram(a.shape, reps);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.transpose = function (a, perm) {
        var program = new transpose_gpu_1.TransposeProgram(a.shape, perm);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.reduce = function (a, reduceType, dtype) {
        var batchSize = a.shape[0];
        var inSize = a.shape[1];
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray(program.outputShape, dtype).as2D(rows, cols);
        this.compileAndRun(program, [a], output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.reduce(output, reduceType, dtype);
    };
    MathBackendWebGL.prototype.argReduce = function (a, reduceType, bestIndicesA) {
        if (bestIndicesA === void 0) { bestIndicesA = null; }
        var batchSize = a.shape[0];
        var inSize = a.shape[1];
        if (bestIndicesA != null) {
            batchSize = bestIndicesA.shape[0];
            inSize = bestIndicesA.shape[1];
        }
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray(program.outputShape, 'int32').as2D(rows, cols);
        var inputs = [a];
        if (bestIndicesA != null) {
            inputs.push(bestIndicesA);
        }
        this.compileAndRun(program, inputs, output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.argReduce(a, reduceType, output);
    };
    MathBackendWebGL.prototype.sum = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        var outputDType = types_1.SumTypesMap[a.dtype];
        return this.reduce(a2D, 'sum', outputDType).reshape(outShape);
    };
    MathBackendWebGL.prototype.argMin = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.argReduce(a2D, 'min').reshape(outShape);
    };
    MathBackendWebGL.prototype.argMax = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.argReduce(a2D, 'max').reshape(outShape);
    };
    MathBackendWebGL.prototype.equal = function (x, y) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, x.shape, y.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [x, y], output);
    };
    MathBackendWebGL.prototype.topKValues = function (ndarray, k) {
        throw new Error('topKValues GPU not yet implemented!');
    };
    MathBackendWebGL.prototype.topKIndices = function (ndarray, k) {
        throw new Error('topKIndices GPU not yet implemented!');
    };
    MathBackendWebGL.prototype.min = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.max = function (a, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, a.rank);
        var _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = a.as2D(-1, inSize);
        return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.divide = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.DIV, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.add = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.subtract = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.ceil = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.CEIL);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.floor = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.FLOOR);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.exp = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.EXP);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.log = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LOG);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.sqrt = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SQRT);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.square = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.relu = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.RELU);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.elu = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ELU);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.eluDer = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ELU_DER);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.selu = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SELU);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.leakyRelu = function (a, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LEAKY_RELU(alpha));
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.clip = function (a, min, max) {
        var program = new clip_gpu_1.ClipProgram(a.shape, min, max);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.abs = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ABS);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.sigmoid = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIGMOID);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.sin = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIN);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.cos = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COS);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.tan = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TAN);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.asin = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ASIN);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.acos = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ACOS);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.atan = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ATAN);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.sinh = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SINH);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.cosh = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COSH);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.tanh = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TANH);
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.step = function (a, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.STEP(alpha));
        return this.compileAndRun(program, [a]);
    };
    MathBackendWebGL.prototype.conv2d = function (x, filter, bias, convInfo) {
        var program = new conv_gpu_1.Conv2DProgram(convInfo, bias != null);
        var inputs = bias != null ? [x, filter, bias] : [x, filter];
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    MathBackendWebGL.prototype.conv2dDerFilter = function (x, dY, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dY]);
    };
    MathBackendWebGL.prototype.conv2dDerBias = function (dY) {
        var program = new conv_backprop_gpu_1.Conv2DDerBiasProgram(dY.shape);
        return this.compileAndRun(program, [dY]);
    };
    MathBackendWebGL.prototype.depthwiseConv2D = function (input, filter, convInfo) {
        var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
        return this.compileAndRun(program, [input, filter]);
    };
    MathBackendWebGL.prototype.maxPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.minPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'min', false);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.avgPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.maxPoolBackprop = function (dy, x, convInfo) {
        var getPositions = true;
        var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);
        var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
        var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
        var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions]);
        maxPoolPositions.dispose();
        return result;
    };
    MathBackendWebGL.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {
        var program = new resize_bilinear_gpu_1.ResizeBilinear3DProgram(x.shape, newShape2D, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.multinomial = function (probs, numSamples, seed) {
        var batchSize = probs.shape[0];
        var numOutcomes = probs.shape[1];
        var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        var customSetup = program.getCustomSetupFunc(seed);
        return this.compileAndRun(program, [probs], output, customSetup);
    };
    MathBackendWebGL.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
        return this.compileAndRun(program, [indices]);
    };
    MathBackendWebGL.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    MathBackendWebGL.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    MathBackendWebGL.prototype.dispose = function () {
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
    };
    return MathBackendWebGL;
}());
exports.MathBackendWebGL = MathBackendWebGL;
var NDArrayMathGPU = (function (_super) {
    __extends(NDArrayMathGPU, _super);
    function NDArrayMathGPU(gpgpu, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        return _super.call(this, new MathBackendWebGL(gpgpu), safeMode) || this;
    }
    NDArrayMathGPU.prototype.getGPGPUContext = function () {
        return this.backend.getGPGPUContext();
    };
    NDArrayMathGPU.prototype.getTextureManager = function () {
        return this.backend.getTextureManager();
    };
    return NDArrayMathGPU;
}(math_1.NDArrayMath));
exports.NDArrayMathGPU = NDArrayMathGPU;
